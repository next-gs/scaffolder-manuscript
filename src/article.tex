% BioMed_Central_Tex_Template_v1.05 %{{{1

\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    

% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
\def\includegraphic{}
\def\includegraphics{}

\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}

% Scaffolder url
\urldef{\scaffolder}\url{http://www.michaelbarton.me.uk/projects/scaffolder/}

% Begin ...
\begin{document}
\begin{bmcformat}

\title{Scaffolder - Software for Microbial Genome Scaffolding.} %{{{1

\author{
  Michael D Barton$^{1}$%
  \email{Michael D Barton - mail@michaelbarton.me.uk}%
\and
  Hazel A Barton\correspondingauthor$^1$%
  \email{Hazel A Barton\correspondingauthor - bartonh@nku.edu}%
      }

\address{\iid(1) Department of Biological Sciences, Northern Kentucky %
University, Nunn Drive, Highland Heights, KY 41076 }%

\maketitle

\clearpage

\begin{abstract} %{{{1

  \paragraph*{Background:} Assembly of short read sequencing data can result in
  a fragmented series of contigs. Therefore a common step in a genome project
  is to join neighbouring sequence regions together and fill gaps using insert
  data generated through PCR. This scaffolding step, however, is non-trivial
  and requires manually editing large blocks of nucleotide sequence. Joining
  sequence contigs together also hides the source of each region in the final
  genome sequence. Taken together, these considerations may make reproducing or
  editing an existing genome build difficult.

  \paragraph*{Methods:} The software outlined ``Scaffolder'' is implemented in
  the Ruby programming language and can be installed via the RubyGems software
  management system. Genome scaffolds are defined using YAML - a markup
  language, which is both human and machine-readable. Command line binaries and
  extensive documentation are provided.

  \paragraph*{Results:} This software allows a genome build to be defined in
  terms of the constituent contigs using a relatively simple to write and edit
  scaffold file syntax. The Scaffolder syntax further allows inserts to be
  added to the scaffold for the purpose of filling unknown sequence regions.
  Defining the genome construction in a file makes the scaffolding process
  reproducible and comparatively easier to edit than raw fasta.

  \paragraph*{Conclusions:} Scaffolder is easy to use genome scaffolding
  software. This tool promotes reproducibility and maintenance in building
  a genome. Scaffolder can be found at \scaffolder.

\end{abstract}

\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}

\clearpage

\section*{Background} %{{{1
%{{{2

High throughput sequencing can produce hundreds of thousands to millions of
sequence reads from a genome. Each read represents the machine-interpreted
nucleotide sequence from a short region in the genome. At the time of writing
high throughput sequencing is limited to producing reads less than $>$1000
nucleotides. Therefore to produce to produce a sequence longer than this
length, e.g. a complete genome, these numerous individual reads must be pieced
together. The process of joining reads into longer sequences is the `assembly'
stage in a genome project \cite{assembly-reviews}. \pb

Assembly software takes the nucleotide reads produced by the sequencing
hardware and, in the ideal case, outputs a complete genome sequence compose of
these individual reads. An analogy to describe this is a jigsaw puzzle. Each
nucleotide read represents a single piece and the final genome sequence is the
completed puzzle. Repetitive nucleotide `repeat' regions within a genome or
biased and incomplete sequencing data may however prevent the genome being
assembled into a continuous sequence. This is analogous to missing jigsaw
pieces or pieces that fit to multiple other pieces. \pb

The recent advent of these current high throughput sequencing methods has lead
to a renewed interest into algorithms for solving the problem of genome
assembly \cite{assembly-reviews}. Genome assembly software is often unable to
completely these sequence reads together due to problems outlined above.
Instead assembly algorithms will generate large contiguous regions of sequence
(`contigs') composed of many individual reads. These represent optimum assembly
of reads into the longest sequences for the assembly algorithm. \pb

The process of ameliorating a draft sequence to a finished continuous sequence
can be expensive in time and laboratory effort. Therefore in many cases a set
of contigs may often describe enough of the genomic content for many research
questions \cite{branscomb2002}. A continuous high-quality `finished' genome
sequence does however provide further depth of information
\cite{parkhill2002,fraser2002}. The benefits of a complete genome sequence
include complete resolution of repeat regions and the exact distances between
genomic elements. This process of joining contigs from assembly together to form
a continuous sequence may be called `scaffolding' or `finishing'. Here on we
use the term scaffolding. \pb

\subsection*{Scaffolding} %{{{2

Scaffolding is the process of joining a series disconnected contigs into
complete continuous sequence. Due to genomic complexity, missing data and
diminishing returns scaffolding may not ultimately produce a final completed
sequence. The process of scaffolding may still however joining a subset of
contigs or additional regions of sequence to fill gaps.

\subsubsection*{Contig Orientation} %{{{3

The sequencing process produces reads from either strand of the DNA helix. The
resulting contigs constructed from these reads therefore point in either of two
DNA strand directions. Contig orientation involves reverse complementing
sequences so that all contigs point in the same direction and represent the
same DNA strand. In the case of microbes this orientation is often the 5`-3`
strand leading away from the origin of replication.

\subsubsection*{Contig Ordering} %{{{3

Contig ordering determines the placement of contigs to best represent the
actual nucleotides as appearing in the genome sequence. This may also determine
if any contigs represent extra-genomic DNA, such as plasmids, and therefore
should be treated separately from genomic contigs. The contig order is commonly
referenced to the origin of replication where the contig containing the
replication start point is first. All subsequent contigs then follow in the
direction of DNA replication.

\subsubsection*{Contig Distancing} %{{{3

Given the order and orientation of contigs determining the distances between
contigs may be useful for estimating genome size. The size of each gaps between
contigs represents the length of an unknown region in the genome. Filling in
these regions in with unknown nucleotide characters (`N') allows a draft
continuous representation of the genome to produced. This draft scaffold
sequence represents both the contigs and unknown regions of sequence between
them.

\subsubsection*{Gap Closing and Filling} %{{{3

During the scaffolding process closing and filling sequence gaps improves the
accuracy of the genome scaffold. This may require returning to the laboratory
to perform additional sequencing or using computational methods. Once all
contigs have been joined and gaps in a scaffold closed the genome may be
considered as finished. In the case of organisms or particular interest
additional sequencing may be performed to further `proof' any low coverage
regions or detect erroneous nucleotides resulting from insertions, deletions or
substitutions.

\subsection*{Computational Methods for Scaffolding} %{{{2

The process of resolving a genome sequence and building a scaffold uses
\emph{in vitro} methods, \emph{in silico} methods, or both in conjunction.
Examples of computation methods is the use of pair reads data, where sequencing
reads are a known distance apart in the genome, or from comparing contigs to
a reference genome. Laboratory methods may use PCR to amplify the DNA in gap
regions, then use traditional Sanger sequencing to determine this sequence.
Computation methods are more preferable as they less costly in laboratory time
and materials compared to manual gap resolution \cite{nagarajan2010}. \pb

The need for computational scaffolding methods has resulted in a variety of
algorithmic approaches. Synteny methods compare the assembled contigs to a more
complete reference genome sequence. Areas of corresponding sequence between the
the two sets are indicative of the possible contig organisation
\cite{richter2007,zhao2008}. \pb

Repeat regions may be responsible for many of the gaps in building a genome
sequence. The existence of tandemly repeated nucleotide regions produces many
reads of similar sequence. The assembly of these regions may result in the
repeats being collapsed into a single instance or ignored by conservative
assembly algorithms. These regions may be reassembled using algorithms
specifically for repeat resolution \cite{mulyukov2002,koren2010}. A related
approach uses uniquely matching reads try find overlaps and bridge across the
gaps between contigs \cite{tsai2010}. \pb

As mentioned above, the genome may be prepared prior to sequencing so that
reads are produced in pairs at a known distance apart. This paired-read data
provides an extra level of information on how contigs may be scaffolded
together. Heuristic graph algorithms may be used to search for optimal
configuration of contigs in the scaffold to take into account this information
\cite{dayarian2010}. Additional data using a reference genome may also be
combined when estimating the best contig configuration \cite{pop2004}. \pb

Finally when the scaffold cannot be completely resolved \emph{in silico}
software packages exist to suggest the likely primers necessary for determining
the sequence in gap regions \cite{gordon2001,nagarajan2010}. \pb

\subsection*{Summary} %{{{2

Taken together these methods provide a wide variety of possible approaches for
scaffolding a genome. Scaffolding however may still however require manual
editing of the scaffold if computational methods do not resolve the final
sequence.  This process involves moving and joining larges blocks of nucleotide
text together. This however may be error-prone and manual editing also
precludes reproducibility of the genome scaffold. \pb

The software outlined here ``Scaffolder'' is aimed at creating a syntax and
software framework for editing a genome scaffold. Scaffolder uses a specific
data syntax to define how contigs are joined, additional sequences inserted,
and specify unknown regions. This syntax allows a scaffold to be edited in much
easier way and makes genome scaffolds reproducible. \pb

\clearpage

\section*{Implementation} %{{{1

\subsection*{Code and Dependencies} %{{{2

Scaffolder is written in the Ruby programming language, version 1.8.7
\cite{ruby-lang}. The scaffolder package is split into two libraries. The first
called ``scaffolder'' contains the core scaffolder application programming
interface (API). The second library ``scaffolder-tools'' contains the
scaffolder command line interface (CLI). \pb

Unit tests were implemented to develop and maintain individual elements of the
source code.  Integration tests were written to test the scaffolder software
interface as a whole. Unit tests were written using the Shoulda and RSpec
\cite{rspec} libraries.  Integration tests were written using the Cucumber
library \cite{rspec}. \pb

The Scaffolder source code is documented using the Yard library \cite{yard}.
Unix manual pages for the command line interface were generated using the Ronn
library \cite{ronn}. The manipulation of biological sequences in Scaffolder is
performed using the BioRuby library \cite{goto2010}. A full list of the
software dependencies in scaffolder can be found in the Gemfile in the root of
each source code directory.\pb

\subsection*{Scaffold file syntax} %{{{2

The choice of nucleotide sequences making up the scaffold is specified using
the YAML syntax \cite{yaml}. YAML is a language format using whitespace and
indentation to produce a machine readable structure. As YAML is a standardised
data format, third-party developers have the option to generate a genome
scaffold using any programming language for which a YAML parser and generator
exists. The YAML website lists parsers for languages including C/C++, Ruby,
Python, Java, Perl, C\#/.NET, PHP, and JavaScript. In addition to being widely
supported YAML formatted scaffold files can be validated for correct syntax
using third party tools such as Kwalify \cite{kwalify}. \pb

As described in the Background section, the initial sequencing data assembly
may result in an incomplete genome build. The use of computational software and
generation of additional sequence using PCR translates into genome scaffolding
as an on-going process. Therefore the scaffold file should be simple to edit
update with new sequence manually in addition to being computationally
tractable. This requirement was therefore second reason YAML was selected,
where YAML is human-readable and should be relatively easy to update in a
standard text editor. \pb

The scaffold file takes the form of a list of entries. Each entry corresponds
to a region of sequence, most likely a contig, in the genome scaffold. The
scaffolder software processes this list of entries in order, converting each to
the corresponding nucleotide sequence. These nucleotide sequences are then
concatenated together to produce the draft genome sequence. Each entry in the
scaffold file may have attributes that define whether a sub-sequence or the
reverse complement of the sequence should be used. The types of attributes
available and an example scaffold file are outlined in the Results and
Discussion section below.  \pb

\clearpage

\section*{Results and Discussion} %{{{1

\subsection*{Scaffolder Simplifies Genome Finishing} %{{{2

The Scaffolder software outlined here is designed to allows manual or
computational joining of nucleotide sequences together into a single contiguous
super sequence. Plain-text files written using the YAML syntax files are used
to specify the nucleotide sequences in the scaffold and how they should be
joined together. This file is described as the ``scaffold file''. \pb

The scaffold file is read by the scaffolder software to determine how the
scaffold sequence should be generated. In addition to specifying which
nucleotides should be used to generate this draft sequence, the scaffold file
allows the sequences to trimmed down to smaller sub-sequences and reverse
complemented if necessary. \pb

The process of genome finishing may involve producing additional nucleotide
sequence to fill gaps in the scaffold. The scaffold file format allows these
additional insert sequences to be added to scaffold to bridge the gaps inside
contigs. These inserts can also be treated in a similar way to larger contig
sequences: trimmed and/or reverse complemented to match the corresponding gap
region. \pb

In the process of build a genome scaffold distances between contigs may be
estimated from paired read insert size or from mapping the contigs to reference
genome. These unknown gap regions are useful to join non-contiguous sequences
together by the estimated size of the region whilst still highlighting areas in
the scaffold to be resolved. The scaffold file also allows for the
specification of these unknown regions. \pb

The scaffold file specifies how the contigs nucleotide sequences are joined
together, however the sequences are not present in the scaffold file. These
nucleotide sequences are instead maintained in a fasta file. A fasta file of
contigs is a common output for assemblers and as such should be readily
available without further processing. Nucleotide sequence are specified in the
scaffold using the first space-delimited word from the fasta header.
Maintaining the nucleotide sequences in a separate file preserves the original
unedited sequence and furthermore separates raw sequence from the markup
describing how it should be used in the scaffold. \pb

\subsection*{Defining a scaffold in a text file} %{{{2

The scaffold file is written using the YAML syntax. YAML is a data format
designed to be both machine readable and easy to edit manually. An example
scaffold file is shown in Figure 1. This file illustrates the text attributes
used to describe a genome scaffold. The basic layout of the scaffold file is as
a list - a series of entries where each entry insert to a region of sequence in
the scaffold super sequence. \pb

\subsubsection*{Simple sequence region} %{{{3

The first line of the scaffold file begins with three dashes. This is
a requirement to indicate the start of a YAML formatted document. Line 2 begins
with a dash character `-', dashes are used to denote entries in a YAML list.
This first line therefore indicates indicate the first entry in the scaffold.
Line 3 is indented by two spaces where whitespace is used to group similar
attributes together. Lines indented by whitespace are linked to the first
non-indented preceding line. \pb

The ``sequence'' tag on line 3 indicates this scaffold entry corresponds to an
entry in the fasta file. The following line, indented by two spaces, indicates
the name of the fasta sequence using the ``source'' keyword. As described above
the first space-delimited word of the fasta header should be used to identify
which sequence is used. Therefore lines 2-4 describe the first entry in the
scaffold as a simple sequence using the fasta sequence named `sequence'. \pb

\subsubsection*{Unresolved sequence region} %{{{3

Line 5 has no whitespace indentation and begins with a dash therefore
describing the next entry in the scaffold. This entry is identified by the
``unresolved'' tag, and specifies a region of unknown nucleotides but known
length. The following line specifies the size of this unknown region. Lines 5-6
therefore insert a region of 20 `N' characters in the scaffold. \pb

\subsubsection*{Trimmed sequence region with multiple inserts} %{{{3

The last entry adds the fasta entry `sequence2' to the scaffold. This entry
demonstrates how sequence may be edited when added to the scaffold. The `start'
and `stop' tags trim the sequence to these coordinates inclusively. The
``reverse'' tag reverse complements this region. \pb

This region further includes the ``inserts'' tag to update the inserted
sequence with additional regions of sequence. These inserts are also added as
a YAML list with each insert listed with a dash on one line followed by the
remainder of the insert errata. \pb

Lines 16-19 illustrate an insert using similar attributes to that of a sequence
entry. The reverse, start and stop tags trim the inserted sequence and the
`source' tag identifies the corresponding fasta sequence. The ``open'' and
``close'' tags on lines 20-21 determine where the insert is added to the
enclosing sequence.  These coordinates inclusively replace the sequence region
within these coordinates with the specified insert fasta sequence. The open and
close positions need not be the same size as the replaced region. \pb

The next insert on lines 23-24 is specified by only the open position tag. This
illustrates that only the one of the `open' or `close' tags is required.  When
only one of these tag is used the corresponding opposing coordinate position is
calculated from the length in the insert fasta sequence. This allows inserts to
bridge into and partially fill gap regions. \pb

\subsubsection*{Scaffolder file attribute processing} %{{{3

The sequence entry in the scaffold file allows multiple sequence-editing
operations to be applied. If applied in different combinations, these
operations could result in different output sequence. An example would be
reverse complementing the sequence then trimming the start of the sequence by
five nucleotides. Performing these actions in the reverse order would produce
a difference output sequence. This section therefore outlines the scaffolder
protocol for processing sequence entries. \pb

\paragraph{Reverse sort inserts:} If the sequence entry contains a list of
inserts these are reverse sorted by the insert close coordinate. The insert
with the largest close position is first in the list and the insert with the
smallest close position is last. This preserves the original indented
coordinates for each insert during the process of adding inserts to the
sequence. \pb

\paragraph{Update sequence with insert:} Each insert sequence is processed
according to any specified attributes. The insert is then added to the
enclosing sequence in the region specified by the open and close coordinates.
\pb

If the insert added to the sequence is a different size compared to the region
it replaces then the sequence start and stop co-ordinates are updated.  For
example if a 7bp insert replaced a 5bp region in the sequence the stop
coordinate of the enclosing sequence would be incremented by the 2bp
difference. As inserts are added by reverse close position order the remaining
inserts are unaffected by this change in the sequence size. \pb

\paragraph{Trimming sequence:} If the sequence has start or stop sequences
specified these are used to trim the sequence to the specified length
inclusively. \pb 

\paragraph{Reverse complement sequence:} If the reverse tag is specified the
sequence is reverse complemented. This is final step in processing the sequence
and results in the sequence being returned for inclusion in the scaffold. \pb

\subsection*{Scaffolder usage} %{{{2

Scaffolder provides a standardised set of Ruby classes and methods (API)
allowing the scaffold to be manipulated programmatically. This allows
scaffolder to be integrated into existing genomics workflows or used with Ruby
build tools such as Rake. \pb

In addition Scaffolder provides a command line interface (CLI) through the
scaffolder binary. This allows the scaffold sequence to be produced and
validated without requiring any Ruby experience. The scaffolder CLI behaves as
a standard Unix tool - returning appropriate exit statuses and providing
appropriate manual pages. The use of both these scaffolder interfaces is
outlined in the following sections. \pb

\subsubsection*{Installation} %{{{3

Scaffolder relies on both the Ruby programming language and the RubyGems
package management system. These are either already present or easily
installed on recent distributions of Mac OSX or Linux. The presence of these
tools can be tested by typing the following on the command line. \pb

  \begin{verbatim}
    ruby -v
    gem -v
  \end{verbatim}

If both these commands return without error this indicates the necessary
system requirements to install and run scaffolder. The scaffolder API and CLI
can then be installed through RubyGems with the following command. \pb

  \begin{verbatim}
    gem install scaffolder scaffolder-tools
  \end{verbatim}

To ensure that the scaffolder CLI is accessible, the RubyGems `bin' directory
should be in the command line path. Assuming that RubyGems are installed in
~/.gem this can be done by adding the following to the ~/.bashrc file. The
corresponding login shell should be updated for other shells such as Zsh, etc..
\pb

  \begin{verbatim}
    export PATH=~/.gem/bin:$PATH
  \end{verbatim}

\subsubsection*{Command Line Interface} %{{{3

The Scaffolder CLI provides functions to validate the scaffold file and build
the draft scaffold sequence. Assuming scaffolder has been installed and the
binary is available in the command line path the following command should run
without error and list the available scaffolder functions. \pb

  \begin{verbatim}
    scaffolder
  \end{verbatim}

Help on a specific command can be found by typing `help' followed by the name
of the command. This returns the corresponding Unix manual page. The following
example will return the manual page for the sequence command. \pb

  \begin{verbatim}
    scaffolder help sequence
  \end{verbatim} 

The ``sequence'' command builds the fasta sequence from the scaffold and fasta
file. Running this command requires the locations of both the scaffold file and
the fasta file to be passed as argument. This will then return the complete
scaffold sequence in fasta format. \pb

  \begin{verbatim}
    scaffolder sequence scaffold.yml sequences.fna
  \end{verbatim}

Scaffolder provides a function to test the scaffold for overlapping insert
coordinates. Overlapping inserts will result in unexpected behaviour as the
coordinates for the first insert may change the insert location for subsequent
inserts. The ``validate'' command will check the scaffold for any such inserts
and return them as a YAML list. \pb

  \begin{verbatim}
    scaffolder validate scaffold.yml sequences.fna
  \end{verbatim}

\subsubsection*{Application programming interface} %{{{3

Scaffolder provides an API allowing Ruby programs to manipulate the scaffold.
This API is detailed in full on the scaffolder website. The following code
snippet outlines how the API may be used to create a script to replicate the
function of the `scaffolder sequence' command described above in the CLI
section. \pb

  \begin{verbatim}
    #!/usr/bin/env ruby

    require 'rubygems'
    require 'scaffolder'

    scaffold_file = ARGV.shift
    sequence_file = ARGV.shift

    scaffold = Scaffolder.new(
      YAML.load(File.read(scaffold_file)),
      sequence_file)

    sequence = scaffold.map{|entry| entry.sequence }.join

    puts sequence
  \end{verbatim}

This code snippet illustrates that the scaffold object is initialised with two
arguments: the YAML loaded scaffold and the location of the fasta sequence
file. The scaffold is an enumerable object and the next line illustrates the
trivial code required to generate the scaffold sequence. Further details of the
classes and method related to each scaffold entry can be found in the
documentation for the Scaffolder::Region class. \pb

\subsection*{Discussion of Scaffolder Approach} %{{{2

The aim of scaffolder are twofold. The first aim is to provide scaffolding
software which is easy to install and simplifies the task of genome finishing.
The second aim is to facilitate reproducibility when joining large nucleotide
sequences together to create a genome scaffold. \pb

\subsubsection*{Simple to use} %{{{3

Scaffolder is designed to be simple to use as possible. Assuming the existence
of Ruby and RubyGems, scaffolder can be installed in a single command line
step. This should negate the possible barriers to use in requiring manual
compilation of the source code. \pb

Scaffolder uses a minimal and compact syntax to described the genome scaffold.
This syntax is simple to construct and edit whilst being succinct and readable.
The aim of this is genome scaffold creation to relatively simple in a common
text editor. Furthermore scaffolder provides extensive documentation both for
the command line tools and for the Scaffolder Ruby API. Therefore should any
part of the scaffolding process be unclear the documentation should make an
solution easy to find. \pb

\subsubsection*{Reproducible genome construction} %{{{3

Constructing a genome sequence using a text file to specify the scaffold means
the same sequence is always output for the same file. Joining large nucleotide
sequences manually cannot however be reliably reproduced. The layout of the
scaffold file furthermore provides a human readable record of how the sequence
was constructed. The same cannot be said for large block of nucleotide
sequences comprised of many source contigs. \pb

Configuring the final sequence in the scaffold file means the build is easier
to edit once already constructed compared with working with an already drafted
sequence. The YAML text format is also facilitates easier comparison of
differences between scaffold build using standard text comparison tools such as
diff. This makes scaffold files easier to store in version control systems and
affords genome finishers similar benefits enjoyed by software developers. \pb 

\clearpage

\section*{Conclusions} %{{{1

Scaffolder follows the Unix philosophy ``Do one thing and do it well''.
Scaffolder focuses on creating a simple to use and install tool for generating
a genome scaffold. The YAML data format for creating a scaffold file is
standardised and easily manipulated programmatically. This thereby follows
a second Unix tenet: ``If your data structures are good enough, the algorithm
to manipulate them should be trivial.''

\clearpage

\section*{Availability and Requirements} %{{{1

  \begin{description}
    \item[Project name:] Scaffolder
    \item[Project home page:] \scaffolder
    \item[Operating system:] Platform Independent. Tested on Mac OS X and
    Debian.
    \item[Programming language:] Ruby
    \item[Other requirements:] RubyGems
    \item[License:] MIT
    \item[Any restrictions to use by non-academics:] None
  \end{description}

\clearpage

\section*{Competing Interests} %{{{1

The authors declare no competing interests.

\section*{List of Abbreviations Used} %{{{1

  \begin{description}
    \item[API:] Application programming interface
    \item[CLI:] Command line interface
    \item[YAML:] YAML Ain't Markup Language\cite{yaml}
  \end{description}

\section*{Authors contributions} %{{{1

MDB developed and maintains the scaffolder tool. MDB and HAB wrote the
manuscript.

\section*{Acknowledgements} %{{{1
  \ifthenelse{\boolean{publ}}{\small}{}

This work was supported by the National Institute for Health: IDeA Network of
Biomedical Research Excellence (KY-INBRE) grant: NIH 2P20 RR016481-09 and the
NIH R15 AREA Program grant: NIH R15GM079775.

\clearpage

% Bibliography {{{1
{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{article} }     % Bibliography file (usually '*.bib' ) 

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

\clearpage

\section*{Figures} %{{{1

\subsection*{Figure 1 - Example of scaffolder file}

An example scaffold file written using the YAML syntax \cite{yaml}. The
scaffold file contains three entries. Each entry is delimited by a `-' on a new
line. The first entry is an example adding a simple sequence. The second entry
inserts an unresolved gap region into the scaffold. The final entry illustrates
a more complex example where the sequece is trimmed, reversed and has
additional sequence inserted. \pb

\end{bmcformat}

\end{document}
