% BioMed_Central_Tex_Template_v1.05 %{{{1

\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    

% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage{trackchanges}
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
\def\includegraphic{}
\def\includegraphics{}

\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}

% Scaffolder url
\urldef{\scaffolder}\url{http://next.gs}

% Begin ...
\begin{document}
\begin{bmcformat}

\title{Scaffolder - Software for Reproducible Genome Scaffolding.} %{{{1

\author{
  Michael D Barton$^{1}$\correspondingauthor%
  \email{Michael D Barton\correspondingauthor  - mail@michaelbarton.me.uk}%
\and
  Hazel A Barton$^1$%
  \email{Hazel A Barton - bartonh@nku.edu}%
      }

\address{\iid(1) Department of Biological Sciences, Northern Kentucky %
University, Nunn Drive, Highland Heights, KY 41076 }%

\maketitle

\clearpage

\begin{abstract} %{{{1

  \paragraph*{Background:} Assembly of short-read sequencing data can result in
  a fragmented non-contiguous series of genomic sequences. Therefore a common
  step in a genome project is to join neighbouring sequence regions together
  and fill gaps in the assembly using additional sequences. This scaffolding
  step, however, is non-trivial and requires manually editing large blocks of
  nucleotide sequence. Joining these sequences together also hides the source
  of each region in the final genome sequence. Taken together, these
  considerations may make reproducing or editing an existing genome build
  difficult.

  \paragraph*{Methods:} The software outlined here, ``Scaffolder,'' is
  implemented in the Ruby programming language and can be installed via the
  RubyGems software management system. Genome scaffolds are defined using
  YAML - a data format, which is both human and machine-readable. Command line
  binaries and extensive documentation are available.

  \paragraph*{Results:} This software allows a genome build to be defined in
  terms of the constituent sequences using a relatively simple syntax to
  define the scaffold. This syntax further allows  unknown regions to be
  defined, and add additional sequences to fill gaps in the scaffold. Defining
  the genome construction in a file makes the scaffolding process reproducible
  and easier to edit compared with FASTA nucleotide sequence.

  \paragraph*{Conclusions:} Scaffolder is easy-to-use genome scaffolding
  software. This tool promotes reproducibility and continuous development in a
  genome project. Scaffolder can be found at \scaffolder.

\end{abstract}

\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}

\clearpage

\section*{Background} %{{{1
%{{{2

High-throughput sequencing can produce hundreds of thousands to millions of
sequence reads from a genome. At the time of writing, high-throughput
sequencing is limited to producing reads less than 1,000 nucleotides in length.
Therefore to resolve a sequence longer than this, such as a complete genome,
these numerous smaller fragments must be pieced together. The process of
joining reads into longer sequences is the `assembly' stage of a genome project
\cite{miller2010}. \pb

Assembly software takes the nucleotide reads produced by sequencing hardware
and, in the ideal case, outputs a single complete genome sequence composed of
these individual fragments. An analogy for this process is a jigsaw puzzle:
each nucleotide read represents a single piece, and the final genome sequence
is the completed puzzle. Sequences of repetitive nucleotide `repeat' regions
within the genome, or biased and incomplete sequencing data, may prevent the
genome being assembled into a continuous sequence. This may be due to not
enough, or multiple different overlaps between reads and is analogous to
missing pieces in the jigsaw or pieces that fit to multiple other pieces. \pb

The advent of high throughput sequencing methods has led to a renewed interest
in algorithms to solve the problem of genome assembly \cite{pop2008,pop2009}.
Nonetheless, due to the complexity of merging large numbers of overlapping
reads genome assembly software may be unable to produce a complete sequence.
Instead, the algorithm may generate several large assembled regions of
sequence (`contigs') composed of the many individual reads that represent
assembly into the longest possible sequences, given the data. Nonetheless,
these contigs represent a fragmented picture of the genome and require
additional work to join together into a complete sequence. \pb

The process of ameliorating a draft sequence into a finished continuous
sequence can be expensive in terms of time and laboratory effort, although the
genomic data present in a set of generated contigs may be sufficient for many
research questions \cite{branscomb2002}. Nevertheless, a continuous
high-quality `finished' genome sequence does provide a greater depth of
information, such as complete resolution of repeat regions and precise
estimates of distances between genomic elements \cite{parkhill2002,fraser2002}.
The process of joining these contigs together to form a continuous genome
sequence is called the `scaffolding' or `finishing' stage and is the focus of
the software described in this article. \pb

\subsection*{Scaffolding} %{{{2

Scaffolding is the process of joining a series of disconnected contigs into
a complete continuous genome sequence. Due to genomic complexity and missing
data, scaffolding may not ultimately produce a final completed sequence, but
may still succeed in joining a subset of contigs together or resolving gaps
between contigs. An overview of the required steps in the scaffolding process
is outlined below:

\subsubsection*{Contig Orientation} %{{{3

The sequencing process generates reads from either strand of the DNA helix and
the resulting contigs constructed from these reads may represent either the
5'~$\rightarrow$~3' or 3'~$\rightarrow$~5' DNA strands with respect to the
origin of replication. Orientating all contigs to point in the same direction
requires reverse complementing sequences where necessary. In the case of
microbial genomes this orientation will be to the 5'~$\rightarrow$~3'
direction following the direction of genome replication.

\subsubsection*{Contig Ordering} %{{{3

Contig ordering determines the placement of observed contigs to best represent
their order in the true genome sequence. The correct placement of each contig
also highlights any extra-genomic DNA, such as plasmids which are scaffolded
separately from the genomic sequence. The order is commonly started at the
contig containing the origin of replication. All subsequent contigs are then
ordered in the 5' $\rightarrow$ 3' direction of DNA replication.

\subsubsection*{Contig Distancing} %{{{3

Given the correct order and orientation, determining the distance between
contigs results in an estimate of the complete genome size. The size of any
inter-contig gaps represents the length of an unknown region in the genome.
Filling these regions with unknown nucleotide characters (`N') allows a draft
continuous sequence, which is useful for representing both the known and
to-be-resolved areas in the genome sequence.

\subsubsection*{Gap Closing} %{{{3

During the scaffolding process, closing and filling gaps between contigs
completes and improves the genome scaffold. Closing gaps may require returning
to the laboratory to perform additional sequencing or using computational
methods of estimating the unknown sequence. This additional sequence is then
used to replace the gap between two contigs, joining them into a single
sequence. Once all contigs have been joined and gaps in a scaffold closed, the
genome may be considered finished.

\subsection*{Computational Methods for Scaffolding} %{{{2

The process of resolving a genome sequence and building a scaffold uses wet
laboratory methods, \emph{in silico} methods, or a combination of both. An
example of a computational method might use the existing paired-read data from
the sequencing stage where reads were produced in pairs at a known distance
apart in the genome. The occurrence of paired reads in separate contigs can be
used to probabilistically estimate the order and distance between these
contigs. Alternatively, laboratory methods may use PCR to amplify the unknown
DNA in a gap region, then use traditional Sanger sequencing to determine the
sequence of this gap. Computational methods are more preferable as they are
less costly in laboratory time and materials compared to manual gap resolution,
and use the available data that exists following sequencing
\cite{nagarajan2010}. Finally when the scaffold cannot be completely resolved,
\emph{in silico} software packages exist to suggest the likely primers
necessary for PCR amplifying the sequence in gap regions \cite{gordon2001}. \pb

Examples of \emph{in silico} methods include using synteny to compare the
assembled contigs to a complete reference genome sequence by searching for
areas of sequence similarity between the two. Any areas of corresponding
sequence with the reference genome can be used to infer contig placement and
build the contigs into a scaffold \cite{richter2007,zhao2008,assefa2009}.
Recombination within each of the two compared genomes can, however, reduce the
effectiveness of this analysis. \pb

Repeat regions may also be responsible for multiple gaps when building
a genome sequence; tandemly repeated nucleotide regions in the genome produce
multiple reads with similar sequence. As many assembly algorithms rely on
sequence overlaps between reads to build a contig, the similarity between
repeat-region reads can result in the assembly collapsing into an artificially
short sequence or being ignored by more conservative assembly algorithms. Such
regions can be resolved by using algorithms specifically reassemble the
collapsed repeat region correctly \cite{mulyukov2002,koren2010}, while
a related approach uses unassembled sequence reads matching the regions around
a scaffold gap to construct a uniquely overlapping set of reads across it
\cite{tsai2010}. \pb

Paired-read data can provide an extra level of information about how contigs
may be scaffolded together. Heuristic scaffolding algorithms take advantage of
this data to search for the optimal configuration of contigs in the scaffold
that matches these paired-read distances \cite{dayarian2010,boetzer2011}.
Synteny data from a reference genome can also be combined with this
paired-read data to estimate the best contig configuration \cite{pop2004}. \pb

These described \emph{in silico} methods provide a wide array of approaches
for merging contigs into a larger, continuous scaffold sequence. Nevertheless
the scaffolding process may still require manually inserting additional
sequences or further joining contigs using PCR-derived sequence. Moving and
editing large blocks of nucleotide text by hand however possibly introduces
human error and precludes any reproducibility of the steps in this process. \pb

The software outlined here, ``Scaffolder,'' aims to address these problems of
reproducibility by creating a file syntax and software framework for editing
a genome scaffold. Scaffolder uses a specific file format to define how
contigs are joined, additional sequences are inserted, and for the
specification of unknown regions. This syntax allows a scaffold to be updated
by simply editing the scaffold file. As such, scaffolder facilitates
a reproducible scaffolding process and provides a concise overview of how the
final genomic scaffold was constructed. \pb

\clearpage

\section*{Implementation} %{{{1

\subsection*{Code and Dependencies} %{{{2

Scaffolder is written in the Ruby programming language using version 1.8.7
\cite{ruby-lang}. The scaffolder package is split into two libraries. The
first called ``scaffolder'' provides the core Scaffolder application
programming interface (API). The second library ``scaffolder-tools'' provides
the Scaffolder command line interface (CLI). \pb

Unit tests were implemented to maintain individual elements of the source code
during development and were written using the Shoulda and RSpec \cite{rspec}
libraries. Integration tests were written to test the Scaffolder software
interface as a whole and were written using the Cucumber library \cite{rspec}.
\pb

The Scaffolder source code is documented using the Yard library \cite{yard}.
Unix manual pages for the command line were generated using the Ronn library
\cite{ronn}. The manipulation of biological sequences in Scaffolder uses the
BioRuby library \cite{goto2010}. A full list of the software dependencies in
Scaffolder can be found in the Gemfile in the root of each source code
directory. \pb

\subsection*{Scaffold File Syntax} %{{{2

The choice of nucleotide sequences comprising the scaffold is specified using
the YAML syntax \cite{yaml}. YAML is a language format using whitespace and
indentation to produce a machine readable structure. As YAML is a standardised
data format, third-party developers have the option to generate a genome
scaffold using any programming language for which a YAML library exists. The
YAML website lists current parsers for languages including C/C++, Ruby, Python,
Java, Perl, C\#/.NET, PHP, and JavaScript. In addition to being widely
supported, YAML-formatted scaffold files can be validated for correct syntax
using third-party tools such as Kwalify \cite{kwalify}. \pb

Initial sequencing data assembly may result in an incomplete genome build.
Generation of additional sequences either through PCR or computational methods
means that genome scaffolding may be an on-going process. The scaffold file
should therefore be simple to update manually in addition to being
computationally tractable. This requirement was also best suited to YAML
syntax which is human-readable and simple to edit in a standard text editor.
\pb

The scaffold file takes the form of a list of entries. Each entry corresponds
to a region of sequence used in the final scaffold sequence. Each entry in the
scaffold file may have attributes that define whether a sub-sequence or the
reverse complement of the sequence should be used. The types of attributes
available, and an example scaffold file are outlined in the Results section.
\pb

\subsection*{Input sequence data and scaffolding process} %{{{2

The input data for Scaffolder is nucleotide sequence in FASTA format file.
These nucleotide sequences can be of any length and for example may be
individual sequences, assembled contigs or contigs which have been joined to
into larger scaffolds. The case in which Scaffolder may be most useful is
using the contigs and scaffolded contigs produced from the previously
assembled set of sequencing reads, combined with additional gap filling
sequences produced by PCR or \emph{in silico} methods as outlined in the
Background. \pb

The scaffolder algorithm reads through the scaffolder file parsing. Each entry
is then converted to corresponding nucleotide sequence by fetching from the
FASTA file and then performing any designated sequence trimming or reverse
complementing. Each of the sequence entries are then joined into a continuous
single super-sequence and returned to the console output. \pb

\clearpage

\section*{Results} %{{{1

\subsection*{Scaffolder Simplifies Genome Finishing} %{{{2

The Scaffolder software facilitates reproducibly joining nucleotide sequences
together into a single contiguous scaffolded super-sequence. Plain-text
scaffold files written in the YAML syntax specify how these sequences should
be joined and the scaffolder software is used to generate the scaffold
sequence from these instructions. In addition to specifying which contigs are
required, the scaffold file allows the contigs to be edited into smaller
sub-sequences or reverse complemented if necessary. The process of genome
finishing may involve producing additional oligonucleotide sequences to fill
unknown regions in the scaffold and the Scaffolder allows these additional
insert sequences to be used to fill these gaps. These inserts can also be
treated in the same manner as larger contig sequences: trimmed and/or reverse
complemented to match the corresponding gap region size and orientation. \pb

The distances between contigs may be estimated from paired-read data or from
mapping the contigs to a reference genome. These inter-contig gap regions are
useful to join separate sequences together by an estimated size and the
scaffold file allows for the specification of such unresolved regions by
inserting regions of `N' nucleotides into the scaffold. The use of these
regions in the scaffold indicates the unresolved regions in the build and their
approximate size. \pb

The scaffold file specifies how sequence regions are joined together; however,
the sequences themselves are not stored in the scaffold file and are instead
maintained as a separate FASTA file. Nucleotide sequences in a FASTA-format
file are the standard output for a genome assembler, and these may be contigs,
sets of contigs scaffolded into larger sequences, or both. These nucleotide
sequences stored in the FASTA file are referenced in the scaffold using the
first word from in the FASTA header of the corresponding sequence. Maintaining
the nucleotide sequences in a separate file preserves the unedited sequence
and decouples the data from the specification of how it should be used to
produce the genome sequence. \pb

\subsection*{Defining a Scaffold as a Text File} %{{{2

The scaffold file is written using the YAML syntax and an example is shown in
Figure 1. This file illustrates the text attributes used to describe
a scaffold and how the sequences are correspondingly joined together in the
genome build. The basic layout of the scaffold file is a list of entries,
where each entry corresponds to a region of sequence in the generated scaffold
super-sequence. \pb

\subsubsection*{Simple sequence region} %{{{3

The first line of the scaffold file in Figure 1 begins with three dashes to
indicate the start of a YAML-formatted document. The first entry (highlighted
in green) begins with a dash character `-' to denote an entry in the YAML
list. This is a requirement of the YAML format: that each entry begins with
a dash line. The next line is indented by two spaces where whitespace is
required to group similar attributes together. The ``sequence'' tag indicates
that this entry corresponds to a sequence in the FASTA file and the following
line indicates the name of this sequence using the ``source'' tag. The first
word of the FASTA header is used to identify which sequence is selected from
the file. Together these three lines describe the first entry in the scaffold
as a simple sequence using the sequence named `sequence1'. On the right hand
side of Figure
1 this produces the first region in the scaffold, also shown in green. \pb

\subsubsection*{Unresolved sequence region} %{{{3

The second entry in the scaffold, highlighted in orange, is identified by the
``unresolved'' tag, indicating a region of unknown sequence but known length.
The second line specifies the size of this unknown region. This entry produces
a region of 20 `N' characters in the scaffold. \pb

\subsubsection*{Trimmed sequence region with multiple inserts} %{{{3

The last entry in the scaffold, highlighted in blue, adds the sequence named
`sequence2' to the scaffold. This entry demonstrates how this sequence may be
manipulated prior to addition to the scaffold. The `start' and `stop' tags trim
the sequence to these coordinates inclusively, while the ``reverse'' tag
instructs scaffolder to also reverse complement the sequence. In the putative
scaffold shown in Figure 1 this completes the scaffold sequence. \pb

The final entry in the scaffold also includes the ``inserts'' tag to add
additional regions of sequence. These inserts are also added as a YAML list,
with each insert beginning with a dash. The first insert, shown in purple,
uses similar attributes to that of a sequence entry; the reverse, start and
stop tags are used to trim and reverse complement the insert. Similarly the
`source' tag identifies the corresponding FASTA sequence as `insert1'. The
``open'' and ``close'' tags are specific to inserts and determine where the
insert is added in the enclosing sequence. The region of the sequence inside
these coordinates is inclusively replaced by the specified insert sequence.
This is visualised in the putative scaffold in Figure 1 by the black lines
bisecting the blue sequence. \pb

The next insert, shown in brown, is specified using only the `open' tag. This
illustrates that only one of either `open' or `close' tags is required when
adding an insert sequence. If only one of the `open' or `close' tags is used
the corresponding opposing `open'/`close' coordinate is calculated from the
length of the insert FASTA sequence. This allows inserts to bridge into, and
partially fill gap regions, without requiring an end coordinate position. \pb

\subsection*{Scaffolder Software Interface} %{{{2

Scaffolder provides a standardised set of Ruby classes and methods (API) for
interacting with the scaffold. This allows Scaffolder to be integrated into
existing genomics workflows or used with Ruby build tools such as Rake. In
addition Scaffolder provides a command line interface (CLI) to validate the
scaffold file and build the draft super sequence. The Scaffolder CLI behaves
as a standard Unix tool and returns appropriate exit codes and manual pages.
The use of both these Scaffolder interfaces is outlined in detail on the
scaffolder website (\scaffolder). \pb

\clearpage

\section*{Discussion} %{{{1

Scaffolding an incomplete genome assembly requires joining contigs and
additional gap-filling sequence using a combination of computational and
laboratory methods. The process of manually editing a scaffold is inherently
hard to reproduce and introduces the possibility of irreducible techniques
and/or human error. In respect to these drawbacks the aims of the Scaffolder
software are twofold: 1) to provide software that is easy to install and
simplifies the task of genome finishing; and 2) to facilitate reproducibility
in the scaffolding and finishing stage of a genome project. \pb

Scaffolder was designed to be as simple to use and, assuming the Ruby and
RubyGems software are present, can be installed in a single command line step.
This should negate any possible barriers to entry which require manual
compilation of source code. Scaffolder also uses a minimal and compact syntax
to describe how the genome scaffold sequence should be generated. This syntax
is simple to construct and edit whilst being succinct and readable. The goal
of this syntax is to make genome scaffolds easy to write in a common text
editor. \pb

Constructing a genome using by specifying the scaffold organisation in text
file makes generating a scaffold super sequence both reproducible and
deterministic for the same file and set of FASTA sequences. In comparison,
joining large nucleotide sequences by hand cannot be reliably reproduced. The
scaffold file furthermore provides a human readable description of how the
scaffold is constructed. Configuring the final sequence in the scaffold file
means the build is easier to edit once already constructed. The YAML text
format allows comparison of differences between scaffold builds using standard
Unix tools such as diff. This makes scaffold files easier to store in version
control systems and allows genome finishers to use methods similar to those in
software development. \pb 

\clearpage

\section*{Conclusions} %{{{1

Scaffolder is software aimed at both bioinformaticians and biologists familiar
with the command line who wish to build a genome scaffold from a set of
contigs. The Scaffolder file format maintains the genome scaffold as a concise
and readable text representation that allows third parties to see how the
genome sequence was scaffolded. This file format also allows a broad overview
of which sequences were included and how they are ordered in the genome
scaffold, something not possible to deduce from a megabase-length string of
nucleotide characters. Scaffolder furthers increases the ease of
reproducibility in genome projects by allowing the scaffold super-sequence to
be reliably reproduced from the same scaffold file. The YAML syntax for
writing the scaffold file is also standardised and simple to manipulate
programmatically. This thereby means the scaffolding process follows the Unix
tenet of ``If your data structures are good enough, the algorithm to
manipulate them should be trivial.''

\clearpage

\section*{Availability and Requirements} %{{{1

  \begin{description}
    \item[Project name:] Scaffolder v0.4.1, Scaffolder Tools v0.1.2
    \item[Project home page:] \scaffolder
    \item[Operating system:] Platform Independent. Tested on Mac OS X and
    Ubuntu.
    \item[Programming language:] Ruby
    \item[Other requirements:] RubyGems
    \item[License:] MIT
    \item[Any restrictions to use by non-academics:] None
  \end{description}

\clearpage

\section*{Competing Interests} %{{{1

The authors declare no competing interests.

\section*{List of Abbreviations Used} %{{{1

  \begin{description}
    \item[API:] Application programming interface
    \item[CLI:] Command line interface
    \item[PCR:] Polymerase chain reaction
    \item[YAML:] YAML ain't markup language\cite{yaml}
  \end{description}

\section*{Authors contributions} %{{{1

MDB developed and maintains the Scaffolder tool. MDB and HAB wrote the
manuscript.

\section*{Acknowledgements} %{{{1
  \ifthenelse{\boolean{publ}}{\small}{}

This work was supported by the National Institute for Health: IDeA Network of
Biomedical Research Excellence (KY-INBRE) grant (NIH 2P20 RR016481-09) and the
NIH R15 AREA Program grant (R15GM079775).

\clearpage

% Bibliography {{{1
{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{article} }     % Bibliography file (usually '*.bib' ) 

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

\clearpage

\section*{Figures} %{{{1

\subsection*{Figure 1 - Example of Scaffolder File and the Resulting Build}

An example scaffold file written using the YAML syntax \cite{yaml} (left) and
the resulting putative scaffold sequence (right). The scaffold contains three
entries and two inserts. Each entry in the scaffold file text is delimited by
a `-' on a new line and highlighted using separate colours. The scaffold
diagram on the right is not to scale and instead illustrates how the scaffold
sequences are joined. \pb

\end{bmcformat}

\end{document}
