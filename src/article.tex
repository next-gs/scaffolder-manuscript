% BioMed_Central_Tex_Template_v1.05 %{{{1

\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    

% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
\def\includegraphic{}
\def\includegraphics{}

\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}

% Scaffolder url
\urldef{\scaffolder}\url{http://next.gs}

% Begin ...
\begin{document}
\begin{bmcformat}

\title{Scaffolder - Software for Reproducible Genome Scaffolding.} %{{{1

\author{
  Michael D Barton$^{1}$\correspondingauthor%
  \email{Michael D Barton\correspondingauthor  - mail@michaelbarton.me.uk}%
\and
  Hazel A Barton$^1$%
  \email{Hazel A Barton - bartonh@nku.edu}%
      }

\address{\iid(1) Department of Biological Sciences, Northern Kentucky %
University, Nunn Drive, Highland Heights, KY 41076 }%

\maketitle

\clearpage

\begin{abstract} %{{{1

  \paragraph*{Background:} Assembly of short-read sequencing data can result in
  a fragmented non-contiguous series of genomic sequences. Therefore a common
  step in a genome project is to join neighbouring sequence regions together
  and fill gaps in the assembly using additional sequence. This scaffolding
  step, however, is non-trivial and requires manually editing large blocks of
  nucleotide sequence. Joining sequence contigs together also hides the source
  of each region in the final genome sequence. Taken together, these
  considerations may make reproducing or editing an existing genome build
  difficult.

  \paragraph*{Methods:} The software outlined here, ``Scaffolder'', is
  implemented in the Ruby programming language and can be installed via the
  RubyGems software management system. Genome scaffolds are defined using YAML
  - a data format, which is both human and machine-readable. Command line
  binaries and extensive documentation are available.

  \paragraph*{Results:} This software allows a genome build to be defined in
  terms of the constituent sequences using a relatively simple format to write
  and edit scaffold file syntax. This syntax further allows  unknown regions to
  be defined, and inserts to be added to the scaffold to fill gaps. Defining
  the genome construction in a file makes the scaffolding process reproducible
  and easier to edit and compare than FASTA nucleotide sequence.

  \paragraph*{Conclusions:} Scaffolder is easy-to-use genome scaffolding
  software. This tool promotes reproducibility and continuous development in a
  genome project. Scaffolder can be found at \scaffolder.

\end{abstract}

\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}

\clearpage

\section*{Background} %{{{1
%{{{2

High-throughput sequencing can produce hundreds of thousands to millions of
sequence reads from a genome. Each sequence represents the machine-read
nucleotides from a short region in the genome. At the time of writing,
high-throughput sequencing is limited to producing reads less than 1,000
nucleotides in length. Therefore to resolve a sequence longer than this, such
as a complete genome, these numerous smaller fragments must be pieced together.
The process of joining reads into longer sequences is the `assembly' stage of
a genome project \cite{miller2010}. \pb

Assembly software takes the nucleotide reads produced by the sequencing
hardware and, in the ideal case, outputs a complete genome sequence composed of
these individual fragments. An analogy for this process is a jigsaw puzzle:
each nucleotide read represents a single piece, and the final genome sequence
is the completed puzzle. Sequences of repetitive nucleotide `repeat' regions
within the genome, or biased and incomplete sequencing data, may prevent the
genome being assembled into a continuous sequence. This may be due to not
enough, or multiple different overlaps between reads and is analogous to
missing pieces in the jigsaw or pieces that fit to multiple other pieces. \pb

The recent advent of these current high throughput sequencing methods has led
to a renewed interest into algorithms for solving the problem of genome
assembly \cite{pop2008,pop2009}; genome assembly software may however be unable
to produce a complete sequence from these reads. In many cases the algorithm
will generate several large assembled regions of sequence (`contigs') composed
of the many available individual reads, which represent the assembly of reads
into the longest possible sequences given the data. Nonetheless, these contigs
represent a fragmented picture of the genome and require additional work to
join together into larger lengths. \pb

The process of ameliorating a draft sequence into a finished continuous
sequence can be expensive in both time and laboratory effort, although the
genomic data present in a set of contigs may often be sufficient for many
research questions \cite{branscomb2002}. Nevertheless, a continuous
high-quality `finished' genome sequence does provide a greater depth of
information, such as complete resolution of repeat regions and precise
estimates of distances between genomic elements \cite{parkhill2002,fraser2002}.
This process of joining contigs together to form a continuous sequence is
called the `scaffolding' or `finishing' stage. \pb

\subsection*{Scaffolding} %{{{2

Scaffolding is the process of joining a series of disconnected contigs into
a complete continuous genome sequence. Due to genomic complexity and missing
data, scaffolding may not ultimately produce a final completed sequence, but
may still succeed in joining a greater subset of contigs together or resolving
gaps. An overview of the required steps in the scaffolding process is outlined
below.

\subsubsection*{Contig Orientation} %{{{3

The sequencing process generates reads from either strand of the DNA helix the
resulting contigs constructed from these reads may point in either direction of
the DNA. Orientating contigs to point in the same direction and represent the
same strand requires reverse complementing sequences where necessary. In the
case of microbial genomes this orientation may be to the 5' $\rightarrow$ 3'
direction leading away from the origin of replication.

\subsubsection*{Contig Ordering} %{{{3

Contig ordering determines the placement of observed contigs to best represent
their order in the true genome sequence. The correct placement of each contig
also highlights any extra-genomic DNA, such as plasmids which are scaffolded
separately from the genomic sequence. The order is commonly started at the
contig containing the origin of replication. All subsequent contigs are then
ordered in the 5' $\rightarrow$ 3' direction of DNA replication.

\subsubsection*{Contig Distancing} %{{{3

Given the correct order and orientation, determining the distance between
contigs results in an estimate of the complete genome size. The size of any
inter-contig gaps represents the length of an unknown region in the genome.
Filling these regions with unknown nucleotide characters (`N') allows a draft
continuous sequence, which is useful for representing both the sequenced and
still to be resolved areas in the genome sequence.

\subsubsection*{Gap Closing} %{{{3

During the scaffolding process, closing and filling gaps between contigs
improves the completeness of the genome scaffold. Closing gaps may require
returning to the laboratory to perform additional sequencing or using
computational methods of estimating the unknown sequence. This additional
sequence is then used to replace the gap between two contigs joining them into
a single sequence if they are not already scaffolded together. Once all contigs
have been joined and gaps in a scaffold closed, the genome may be considered
finished.

\subsection*{Computational Methods for Scaffolding} %{{{2

The process of resolving a genome sequence and building a scaffold uses
\emph{in vitro} methods, \emph{in silico} methods, or a combination of both. An
example of a computational method might use paired-read data, where the
sequencing reads are produced in pairs at a known distance apart in the genome.
The occurrence of a pair of reads in separate contigs can be used to estimate
the order and distance between the contigs. Alternatively, laboratory methods
may use PCR to amplify the unknown DNA in a gap region, then use traditional
Sanger sequencing to determine the gap sequence. Computational methods are more
preferable, as they are less costly in laboratory time and materials compared
to manual gap resolution and uses the available data that exists following
sequencing \cite{nagarajan2010}. \pb

Synteny methods compare the assembled contigs to a more complete reference
genome sequence searching for areas of sequence similarity between the two.
Areas of corresponding sequence between the two sets can be used to infer
contig placement and build the contigs into a scaffold
\cite{richter2007,zhao2008,assefa2009}. Recombination between the two genomes
can, however, reduce the effectiveness of this analysis. Repeat regions may
also be responsible for many of the gaps in building a genome sequence. The
existence of tandemly repeated nucleotide regions produces many similar reads
fromgenome sequencing. The assembly of reads generated from repeat regions can
result in the assembly collapsing into a single repeat instance or ignored by
more conservative assembly algorithms. These regions may however be resolved by
using reassembly algorithms specifically for repeat resolution
\cite{mulyukov2002,koren2010}. Similarly a related approach may use unassembled
sequence reads matching the regions around a scaffold gap to construct
a uniquely overlapping set of reads across the gap \cite{tsai2010}. \pb

Paired-read data provides an extra level of information about how contigs may
be scaffolded together. Heuristic algorithms may take advantage of this data to
search for optimal configuration of contigs in the scaffold using paired-read
distances \cite{dayarian2010,boetzer2011}. Additional data using a reference
genome may also be combined when estimating the best contig configuration
\cite{pop2004}. Finally when the scaffold cannot be completely resolved,
\emph{in silico} software packages exist to suggest the likely primers
necessary for PCR amplifying the sequence in gap regions
\cite{gordon2001,nagarajan2010}. \pb

These methods provide a wide array of approaches for merging contigs into
larger continuous scaffold sequences. The scaffolding process may still however
require inserting additional sequence or joining contigs using PCR-derived
information from the laboratory. This manual stage in the finishing process
comprises moving and editing large blocks of nucleotide text by hand which is
subject to human error and precludes any reproducibility of the steps taken.
\pb

The software outlined here, ``Scaffolder'', aims to address these problems by
creating a file syntax and software framework for editing a genome scaffold.
Scaffolder uses a specific file format to define how contigs are joined,
additional sequences inserted, and for the specification of unknown regions.
This syntax allows a scaffold to be updated by simply editing the scaffold
file. Scaffolder facilites a reproducible scaffolding process and provides
a concise overview of how the scaffold was constructed. \pb

\clearpage

\section*{Implementation} %{{{1

\subsection*{Code and Dependencies} %{{{2

Scaffolder is written in the Ruby programming language, version 1.8.7
\cite{ruby-lang}. The scaffolder package is split into two libraries. The first
called ``scaffolder'' contains the core Scaffolder application programming
interface (API). The second library ``scaffolder-tools'' contains the
Scaffolder command line interface (CLI). \pb

Unit tests were implemented to maintain individual elements of the source code
during development and were written using the Shoulda and RSpec \cite{rspec}
libraries. Integration tests were written to test the Scaffolder software
interface as a whole and were written using the Cucumber library \cite{rspec}.
\pb

The Scaffolder source code is documented using the Yard library \cite{yard}.
Unix manual pages for the command line were generated using the Ronn library
\cite{ronn}. The manipulation of biological sequences in Scaffolder uses the
BioRuby library \cite{goto2010}. A full list of the software dependencies in
Scaffolder can be found in the Gemfile in the root of each source code
directory. \pb

\subsection*{Scaffold File Syntax} %{{{2

The choice of nucleotide sequences comprising the scaffold is specified using
the YAML syntax \cite{yaml}. YAML is a language format using whitespace and
indentation to produce a machine readable structure. As YAML is a standardised
data format, third-party developers have the option to generate a genome
scaffold using any programming language for which a YAML library exists. The
YAML website lists current parsers for languages including C/C++, Ruby, Python,
Java, Perl, C\#/.NET, PHP, and JavaScript. In addition to being widely
supported, YAML-formatted scaffold files can be validated for correct syntax
using third-party tools such as Kwalify \cite{kwalify}. \pb

Initial sequencing data assembly may result in an incomplete genome build.
Generation of additional sequences either through PCR or computational methods
means that genome scaffolding may be an on-going process. The scaffold file
should therefore be simple to update manually in addition to being
computationally tractable. This requirement was also best suited to YAML which
is human-readable and simple to edit in a standard text editor. \pb

The scaffold file takes the form of a list of entries. Each entry corresponds
to a region of sequence used in the final scaffold sequence. The Scaffolder
software processes this list in order, converting each entry to the
corresponding nucleotide sequence, all entries are then concatenated to produce
a draft super sequence. Each entry in the scaffold file may have attributes
that define whether a sub-sequence or the reverse complement of the sequence
should be used. The types of attributes available, and an example scaffold file
are outlined below. \pb

\clearpage

\section*{Results} %{{{1

\subsection*{Scaffolder Simplifies Genome Finishing} %{{{2

The Scaffolder software allows computational joining of nucleotide sequences
together into a single contiguous scaffolded super-sequence. Plain-text
scaffold files written in the YAML syntax specify how these sequences should be
joined and the scaffolder software is used to generate the scaffold sequence.
In addition to specifying which contigs are required, the scaffold file allows
the contigs to be edited into smaller sub-sequences or reverse complemented if
necessary. The process of genome finishing may involve producing additional
oligonucleotide sequences to fill unknown regions in the scaffold. The scaffold
file format allows these additional insert sequences to bridge gaps. These
inserts can also be treated in a similar way to larger contig sequences:
trimmed and/or reverse complemented to match the corresponding gap region. \pb

The distances between contigs may be estimated from paired-read data or from
mapping the contigs to a reference genome. These inter-contig gap regions are
useful to join separate sequences together by an estimated size and the
scaffold file allows for the specification of such unresolved regions. The use
of these regions in the scaffold indicates the unresolved regions in the build
and their approximate size. \pb

The scaffold file specifies how sequence regions are joined together; however
the sequences themselves are not stored in the scaffold file and are instead
maintained as a separate FASTA file. Nucleotide sequences in a FASTA-formatted
file are the standard output for a genome assembler, and these may be contigs,
sets of contigs scaffolded into larger sequences, or both. These nucleotide
sequences stored in the FASTA file are referenced in the scaffold using the
first word from in the FASTA header of the corresponding sequence. Maintaining
the nucleotide sequences in a separate file preserves the unedited sequence and
decouples the data from the scaffold file describing how it should be used to
in the genome sequence. \pb

\subsection*{Defining a Scaffold as a Text File} %{{{2

The scaffold file is written using the YAML syntax and an example is shown in
Figure 1. This file illustrates the text attributes used to describe a scaffold
and how the sequences are joined together in the genome build. The basic layout
of the scaffold file is a list of entries, where each entry corresponds to
a region of sequence in the generated scaffold super-sequence. \pb

\subsubsection*{Simple sequence region} %{{{3

The first line of the scaffold file begins with three dashes to indicate the
start of a YAML-formatted document. The first entry (highlighted in green)
begins with a dash character `-' to denote an entry in the YAML list. This is
a requirement of the YAML format: that each entry begins with a dash line. The
next line is indented by two spaces as whitespace is required to group similar
attributes together. The ``sequence'' tag indicates that this entry corresponds
to a sequence in the FASTA file and the following line indicates the name of
this sequence using the ``source'' tag. As described the first word of the
FASTA header is used to identify which sequence is selected from the file.
Together these three lines describe the first entry in the scaffold as a simple
sequence using the sequence named `sequence1'. On the right hand side of Figure
1 this produces the first region in the scaffold, also shown in green. \pb

\subsubsection*{Unresolved sequence region} %{{{3

The second entry in the scaffold, highlighted in orange, is identified by the
``unresolved'' tag, indicating a region of unknown sequence but known length.
The second line specifies the size of this unknown region. This entry produces
a region of 20 `N' characters in the scaffold. \pb

\subsubsection*{Trimmed sequence region with multiple inserts} %{{{3

The last entry in the scaffold, highlighted in blue, adds the sequence named
`sequence2' to the scaffold. This entry demonstrates how this sequence may be
manipulated prior to addition to the scaffold. The `start' and `stop' tags trim
the sequence to these coordinates inclusively, while the ``reverse'' tag
instructs scaffolder to also reverse complement the sequence. In the scaffolded
genome shown in Figure 1 this completes the scaffold sequence. \pb

The final entry in the scaffold also includes the ``inserts'' tag to add
additional regions of sequence. These inserts are also added as a YAML list,
with each insert beginning with a dash. The first insert, shown in purple,
similar attributes to that of a sequence entry; the reverse, start and stop
tags are used to trim and reverse complement the insert. Similarly the `source'
tag identifies the corresponding FASTA sequence as `insert1'. The ``open'' and
``close'' tags are specific to inserts and determine where the insert is added
in the enclosing sequence. The region of the sequence inside these coordinates
is inclusively replaced by the specified insert sequence. This is visualised in
the putative gene Figure 1 by the black lines bisecting the blue sequence. \pb

The next insert, shown in brown, is specified using only the `open' tag. This
illustrates that only one of either `open' or `close' tags is required when
adding an insert sequence. If only one of the `open' or `close' tags is used
the corresponding opposing position distance is calculated from the length of
the insert FASTA sequence. This allows inserts to bridge into, and partially
fill gap regions without requiring an end coordinate position. \pb

\subsection*{Scaffolder Software Interface} %{{{2

Scaffolder provides a standardised set of Ruby classes and methods (API) for
interacting with the scaffold. This allows Scaffolder to be integrated into
existing genomics workflows or used with Ruby build tools such as Rake. In
addition Scaffolder provides a command line interface (CLI) to validate the
scaffold file and build a draft super sequence. The Scaffolder CLI behaves as
a standard Unix tool and returns appropriate exit codes and manual pages. The
use of both these Scaffolder interfaces is outlined in detail on the scaffolder
website (\scaffolder). \pb

\section*{Discussion} %{{{1

Scaffolding requires joining assembled contigs and insert additional sequence
data using a combination of computational and laboratory methods. The process
of manually editing a scaffold is inherently hard to reproduce and introduces
the possibility of human error. The aims of this Scaffolder software are
therefore twofold. The first is providing software that is easy to install and
simplifies the task of genome finishing. The second aim is to facilitate
reproducibility when joining large nucleotide sequences together to create
a genome sequence. \pb

Scaffolder was designed to be as simple to use and, assuming the Ruby and
RubyGems software are present, Scaffolder can be installed in a single command
line step. This should negate any possible barriers to entry which require
manual compilation of source code. Scaffolder also uses a minimal and compact
syntax to describe the genome scaffold. This syntax is simple to construct and
edit whilst being succinct and readable. The goal of this syntax is to make
genome scaffolds easy to make in a common text editor. The use of word
processors for this task is however discouraged. \pb

Constructing a genome using a text file makes generating a scaffold super
sequence both reproducible and deterministic for the same scaffold and FASTA
sequence file. In comparison, joining large nucleotide sequences by hand cannot
be reliably reproduced. The scaffold file furthermore provides a human readable
description of how the scaffold is constructed. Configuring the final sequence
in the scaffold file means the build is easier to edit once already
constructed. The YAML text format allows comparison of differences between
scaffold builds using standard Unix tools such as diff. This makes scaffold
files easier to store in version control systems and allows genome finishers to
use methods similar to those in software development. \pb 

\clearpage

\section*{Conclusions} %{{{1

Scaffolder is software aimed at bioinformaticians and biologists familiar with
the command line who wish to build a genome sequence scaffold. The file format
maintains the scaffold in a concise and readable way allowing third parties to
see how the genome sequence was assembled. This file format allows a broad
overview of of which sequences were included and how they are ordered,
something not possible from a megabase-length strings of nucleotide characters.
Scaffolder furthers the case for reproducibility in genome projects by allowing
the scaffold super-sequence to be reliably reproduced from the same scaffold
file. The YAML syntax for writing the scaffold file is also standardised and
simple to manipulate programmatically. This thereby means the scaffolding
process follows the Unix tenet of: ``If your data structures are good enough,
the algorithm to manipulate them should be trivial.''.

\clearpage

\section*{Availability and Requirements} %{{{1

  \begin{description}
    \item[Project name:] Scaffolder v0.4.1, Scaffolder Tools v0.1.2
    \item[Project home page:] \scaffolder
    \item[Operating system:] Platform Independent. Tested on Mac OS X and
    Debian.
    \item[Programming language:] Ruby
    \item[Other requirements:] RubyGems
    \item[License:] MIT
    \item[Any restrictions to use by non-academics:] None
  \end{description}

\clearpage

\section*{Competing Interests} %{{{1

The authors declare no competing interests.

\section*{List of Abbreviations Used} %{{{1

  \begin{description}
    \item[API:] Application programming interface
    \item[CLI:] Command line interface
    \item[PCR:] Polymerase chain reaction
    \item[YAML:] YAML ain't markup language\cite{yaml}
  \end{description}

\section*{Authors contributions} %{{{1

MDB developed and maintains the Scaffolder tool. MDB and HAB wrote the
manuscript.

\section*{Acknowledgements} %{{{1
  \ifthenelse{\boolean{publ}}{\small}{}

This work was supported by the National Institute for Health: IDeA Network of
Biomedical Research Excellence (KY-INBRE) grant (NIH 2P20 RR016481-09) and the
NIH R15 AREA Program grant (R15GM079775).

\clearpage

% Bibliography {{{1
{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{article} }     % Bibliography file (usually '*.bib' ) 

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

\clearpage

\section*{Figures} %{{{1

\subsection*{Figure 1 - Example of Scaffolder File and the Resulting Build}

An example scaffold file written using the YAML syntax \cite{yaml} (left) and
the resulting putative scaffold (right). The scaffold contains three entries
and two inserts. Each entry in the scaffold file text is delimited by a `-' on
a new line and highlighted using separate colours. The scaffold diagram on the
right is not to scale but illustrates how the scaffold sequences are joined.
\pb

\end{bmcformat}

\end{document}
