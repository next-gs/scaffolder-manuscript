% BioMed_Central_Tex_Template_v1.05 %{{{1

\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    

% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
\def\includegraphic{}
\def\includegraphics{}

\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}

% Scaffolder url
\urldef{\scaffolder}\url{http://www.michaelbarton.me.uk/projects/scaffolder/}

% Begin ...
\begin{document}
\begin{bmcformat}

\title{Scaffolder - Software for Microbial Genome Scaffolding.} %{{{1

\author{
  Michael D Barton$^{1}$%
  \email{Michael D Barton - mail@michaelbarton.me.uk}%
\and
  Hazel A Barton\correspondingauthor$^1$%
  \email{Hazel A Barton\correspondingauthor - bartonh@nku.edu}%
      }

\address{\iid(1) Department of Biological Sciences, Northern Kentucky%
University, Nunn Drive, Highland Heights, KY 41076 }%

\maketitle

\begin{abstract} %{{{1

  \paragraph*{Background:} Assembly of short read sequencing data can result in
  a fragmented series of contigs. Therefore a common step in a genome project
  is to join neighbouring sequence regions together and fill gaps using insert
  data generated through PCR. This scaffolding step, however, is non-trivial
  and requires manually editing large blocks of nucleotide sequence. Joining
  sequence contigs together also hides the source of each region in the final
  genome sequence. Taken together, these considerations may make reproducing or
  editing an existing genome build difficult.

  \paragraph*{Methods:} The software outlined ``Scaffolder'' is implemented in
  the Ruby programming language and can be installed via the RubyGems software
  management system. Genome scaffolds are defined using YAML - a markup
  language, which is both human and machine-readable. Command line binaries and
  extensive documentation are provided.

  \paragraph*{Results:} This software allows a genome build to be defined in
  terms of the constituent contigs using a relatively simple to write and edit
  scaffold file syntax. The Scaffolder syntax further allows inserts to be
  added to the scaffold for the purpose of filling unknown sequence regions.
  Defining the genome construction in a file makes the scaffolding process
  reproducible and comparatively easier to edit than raw fasta.

  \paragraph*{Conclusions:} Scaffolder is easy to use genome scaffolding
  software. This tool promotes reproducibility and maintenance in building
  a genome. Scaffolder can be found at \scaffolder.

\end{abstract}

\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}

\section*{Background} %{{{1
%{{{2

High throughput sequencing can produce hundreds of thousands to millions of
sequence reads from a genome. Each read represents the machine-interpreted
nucleotide sequence from a short region in the genome. At the time of writing
high throughput sequencing is limited to producing reads less than $>$1000
nucleotides. Therefore to produce to produce a sequence longer than this
length, e.g. a complete genome, these numerous individual reads must be pieced
together. The process of joining reads into longer sequences is the `assembly'
stage in a genome project \cite{assembly-reviews}. \pb

Assembly software takes the nucleotide reads produced by the sequencing
hardware and, in the ideal case, outputs a complete genome sequence compose of
these individual reads. An analogy to describe this is a jigsaw puzzle. Each
nucleotide read represents a single piece and the final genome sequence is the
completed puzzle. Repetitive nucleotide `repeat' regions within a genome or
biased and incomplete sequencing data may however prevent the genome being
assembled into a continuous sequence. This is analogous to missing jigsaw
pieces or pieces that fit to multiple other pieces. \pb

The recent advent of these current high throughput sequencing methods has lead
to a renewed interest into algorithms for solving the problem of genome
assembly \cite{assembly-reviews}. Genome assembly software is often unable to
completely these sequence reads together due to problems outlined above.
Instead assembly algorithms will generate large contiguous regions of sequence
(`contigs') composed of many individual reads. These represent optimum assembly
of reads into the longest sequences for the assembly algorithm. \pb

The process of ameliorating a draft sequence to a finished continuous sequence
can be expensive in time and laboratory effort. Therefore in many cases a set
of contigs may often describe enough of the genomic content for many research
questions \cite{branscomb2002}. A continuous high-quality `finished' genome
sequence does however provide further depth of information
\cite{parkhill2002,fraser2002}. The benefits of a complete genome sequence
include complete resolution of repeat regions and the exact distances between
genomic elements. This process of joining contigs from assembly together to form
a continuous sequence may be called `scaffolding' or `finishing'. Here on we
use the term scaffolding. \pb

\subsection*{Scaffolding} %{{{2

Scaffolding is the process of joining a series disconnected contigs into
complete continuous sequence. Due to genomic complexity, missing data and
diminishing returns scaffolding may not ultimately produce a final completed
sequence. The process of scaffolding may still however joining a subset of
contigs or additional regions of sequence to fill gaps.

\subsubsection*{Contig Orientation} %{{{3

The sequencing process produces reads from either strand of the DNA helix. The
resulting contigs constructed from these reads therefore point in either of two
DNA strand directions. Contig orientation involves reverse complementing
sequences so that all contigs point in the same direction and represent the
same DNA strand. In the case of microbes this orientation is often the 5`-3`
strand leading away from the origin of replication.

\subsubsection*{Contig Ordering} %{{{3

Contig ordering determines the placement of contigs to best represent the
actual nucleotides as appearing in the genome sequence. This may also determine
if any contigs represent extra-genomic DNA, such as plasmids, and therefore
should be treated separately from genomic contigs. The contig order is commonly
referenced to the origin of replication where the contig containing the
replication start point is first. All subsequent contigs then follow in the
direction of DNA replication.

\subsubsection*{Contig Distancing} %{{{3

Given the order and orientation of contigs determining the distances between
contigs may be useful for estimating genome size. The size of each gaps between
contigs represents the length of an unknown region in the genome. Filling in
these regions in with unknown nucleotide characters (`N') allows a draft
continuous representation of the genome to produced. This draft scaffold
sequence represents both the contigs and unknown regions of sequence between
them.

\subsubsection*{Gap Closing and Filling} %{{{3

During the scaffolding process closing and filling sequence gaps improves the
accuracy of the genome scaffold. This may require returning to the laboratory
to perform additional sequencing or using computational methods. Once all
contigs have been joined and gaps in a scaffold closed the genome may be
considered as finished. In the case of organisms or particular interest
additional sequencing may be performed to further `proof' any low coverage
regions or detect erroneous nucleotides resulting from insertions, deletions or
substitutions.

\subsection*{Computational Methods for Scaffolding} %{{{2

The process of resolving a genome sequence and building a scaffold uses
\emph{in vitro} methods, \emph{in silico} methods, or both in conjunction.
Examples of computation methods is the use of pair reads data, where sequencing
reads are a known distance apart in the genome, or from comparing contigs to
a reference genome. Laboratory methods may use PCR to amplify the DNA in gap
regions, then use traditional Sanger sequencing to determine this sequence.
Computation methods are more preferable as they less costly in laboratory time
and materials compared to manual gap resolution \cite{nagarajan2010}. \pb

The need for computational scaffolding methods has resulted in a variety of
algorithmic approaches. Synteny methods compare the assembled contigs to a more
complete reference genome sequence. Areas of corresponding sequence between the
the two sets are indicative of the possible contig organisation
\cite{richter2007,zhao2008}. \pb

Repeat regions may be responsible for many of the gaps in building a genome
sequence. The existence of tandemly repeated nucleotide regions produces many
reads of similar sequence. The assembly of these regions may result in the
repeats being collapsed into a single instance or ignored by conservative
assembly algorithms. These regions may be reassembled using algorithms
specifically for repeat resolution \cite{mulyukov2002,koren2010}. A related
approach uses uniquely matching reads try find overlaps and bridge across the
gaps between contigs \cite{tsai2010}. \pb

As mentioned above, the genome may be prepared prior to sequencing so that
reads are produced in pairs at a known distance apart. This paired-read data
provides an extra level of information on how contigs may be scaffolded
together. Heuristic graph algorithms may be used to search for optimal
configuration of contigs in the scaffold to take into account this information
\cite{dayarian2010}. Additional data using a reference genome may also be
combined when estimating the best contig configuration \cite{pop2004}. \pb

Finally when the scaffold cannot be completely resolved \emph{in silico}
software packages exist to suggest the likely primers necessary for determining
the sequence in gap regions \cite{gordon2001,nagarajan2010}. \pb

\subsection*{Summary} %{{{2

Taken together these methods provide a wide variety of possible approaches for
scaffolding a genome. Scaffolding however may still however require manual
editing of the scaffold if computational methods do not resolve the final
sequence.  This process involves moving and joining larges blocks of nucleotide
text together. This however may be error-prone and manual editing also
precludes reproducibility of the genome scaffold. \pb

The software outlined here ``Scaffolder'' is aimed at creating a syntax and
software framework for editing a genome scaffold. Scaffolder uses a specific
data syntax to define how contigs are joined, additional sequences inserted,
and specify unknown regions. This syntax allows a scaffold to be edited in much
easier way and makes genome scaffolds reproducible. \pb

\section*{Implementation} %{{{1

\subsection*{Code and Dependencies} %{{{2

Scaffolder is written in the Ruby programming language, version 1.8.7
\cite{ruby-lang}. Unit tests were implemented during development to maintain
functionality of individual elements of source code. Integration tests were
also written to test the scaffold software interface as a whole. These unit and
integration tests were written using the RSpec and Cucumber libraries
respectively\cite{rspec}.\pb

The Scaffolder source code is documented using the Yard library\cite{yard}.
Unix manual pages for the command line interface were generated using the Ronn
library\cite{ronn}. The manipulation of biological sequences in Scaffolder is
performed using the BioRuby library\cite{bioruby}. A full list of the software
dependencies in scaffolder can be found in the Gemfile in the root of source
code directory.\pb

\subsection*{Scaffold file syntax} %{{{2

The choice of nucleotide sequences comprising the genome scaffold is specified
in YAML \cite{yaml}. YAML is a language format for data using white-space and
indentation to produce a machine readable structure. As a standardised data
format third-party developers have the option to generate a genome scaffold
using any programming language for which a YAML parser exists. Furthermore YAML
formatted scaffold files can be validated using third party tools such as
Kwalify\cite{kwalify}.\pb

The initial assembly of sequencing reads may result in an incomplete genome
build. Comparison of contigs to reference genomes and the generation of
additional sequence from PCR translates to genome finishing as an ongoing
process. Therefore the scaffold file should be simple to edit manually in
addition to being computationally tractable. This requirement for the scaffold
files to be modifiable in a simple simple text editor is the second reason YAML
was selected as the format for scaffold files.\pb

The form of the scaffold file is a list of entries. Each entry corresponds to
a length of sequence in the the draft genome sequence. When generating the
genome sequence from the scaffold file each entry is processed in order. Each
of the nucleotide sequence specified by the scaffold file entries are
concatenated together to produce the draft genome sequence. Each entry in the
scaffold file may have attributes that define whether a sub-sequence or the
reverse complement of the sequence should be used. The types of attributes are
outlined in the Results and Discussion section below.\pb

\section*{Results and Discussion} %{{{1

\subsection*{Scaffolder Simplifies Genome Finishing} %{{{2

The Scaffolder software allows manual or computational joining of multiple
discontiguous nucleotide sequences together into a contiguous super sequence.
Simple plain-text configuration files are used to select the nucleotide
sequences in the scaffold and how they should be joined together. This is
called the ``scaffold file''. \pb

The scaffold file is read by the scaffolder software to determine how the
scaffold super sequence is generated. In addition to specifying which
nucleotides should be used to generate the draft super sequence, the scaffold
file allows the sequences to trimmed down to smaller sub-sequences and to
reverse complement the sequence if necessary. \pb

There may be unknown regions in the sequences used in the scaffold. Region of
nucleotide sequence the assembler was unable to determine the nucleotide
sequence. The process of genome finishing may involve determining the correct
nucleotide sequence for these regions then filling the gaps with the additional
correct sequence. The scaffold file specifically allows these inserts to be
added to scaffold. These inserts can be treated the same way as a larger
contig: trimmed and/or reversed to match the required gap region. \pb

When scaffolding a genome there may be regions of sequence approximate size
region may be estimated from mate-pair insert size or from mapping the contigs
to reference genome. These unknown regions are useful to join non-contiguous
sequences together by the estimated size of the region whilst still
highlighting areas in the genome to be resolved. These unknown regions can be
specified in the scaffold file for the above reasons. \pb

The original raw nucleotide sequence for each assembled contig or insert
sequence is maintained in a fasta file. The fasta file of contigs is a common
output for assemblers and as such should be readily available after assembly
without additional processing. The choice of the nucleotide sequence to use in
the scaffold is specified using the first space-delimited word from the fasta
header of the sequence. By maintaining the nucleotide sequences in a separate
file this preserves the original raw sequence in the fasta file. Furthermore
this separates the actual nucleotide sequence from the determination of how it
is selected and edited in the final genome sequence. \pb

\subsection*{Defining a scaffold in a text file} %{{{2

The scaffold file is written using `YAML', a data format designed to be both
machine readable and manually editable. An example of a scaffold file in YAML
format is shown in Figure 1. This example scaffold file illustrates the
available features in scaffolder. The basic layout of the scaffold file is as
a list - a series of entries where each entry defines a region of sequence to
be generated for the final super sequence. In the final super sequence each of
the entries are joined together to generate a single continuous sequences. \pb

\subsubsection*{Simple sequence region} %{{{3

The first line of the scaffold file begins with three dashes. This is
a requirement to indicate the start of a YAML formatted document. Line 2 begins
with a dash character `-' denoting the first entry in the sequence scaffold.
Line 3 is indented by two spaces. Whitespace is used to delimite attributes in
the file. Lines with an incremented level of white space are considered linked
to the first preceeding non-indented line. \pb

The ``sequence'' tag used on line 3 indicates that this region is in the
scaffold will contain nucleotide sequence from the fasta file. The following
line indented by two spaces and indicating an attribute of the sequence entry
defined on line 3. In this case the ``source'' keyword identifies the name of
the sequence to be inserted into the scaffold. As described above the first
space-delimited word of the fasta header should be used to identify the
sequence. Taken together lines 2-4 describe the first entry in the scaffold is
a simple sequence which the identifier `sequence'. \pb

\subsubsection*{Unresolved sequence region} %{{{3

Line 5 has no whitespace indentation and begins with a dash and therefore
describes the next entry in the scaffold. This entry is identified by the
``unresolved'' tag, and specifies a region of unknown nucleotides but known
length. The following line specifies the size of this unknown region. Lines 5-6
therefore insert a region of 20 `N' characters in the super sequence directly
following the region defined by the first entry on lines 2-5. \pb

\subsubsection*{Trimmed sequence region with multiple inserts} %{{{3

The last entry adds the sequence 'sequence2' in the scaffold file. This entry
demonstrates three further attributes for a sequence entry.The `start' and
`stop' tags are used to trim the sequence used in the scaffold to these
coordinates inclusively. The ``reverse'' tag is used to reverse complement this
region in the final super sequence. \pb

This region further includes the ``inserts'' tag to update the inserted
sequence with additional regions of sequence. These inserts are also added as
a YAML list with each insert listed with a dash on one line followed by the
remainder of the insert errata. \pb

Lines 16-19 illustrate an insert using similar attributes to that of a sequence
entry. The reverse, start and stop tags trim the inserted sequence and the
`source' tag identifies the corresponding fasta sequence. The ``open'' and
``close'' tags on lines 20-21 determine where the insert is added to the
enclosing sequence.  These coordinates inclusively replace the region within
these coordinates with the specified fasta sequence. The open and close
positions need not be the same size as the inserted sequence. \pb

The next insert on lines 23-24 specifies only the open position. This
illustrate that only the one of the `open' or `close' tags is required.  When
only open or close tag is used then the opposing position is calculated from
the length on the insert fasta sequence. This allows inserts to partially fill
gap regions in sequences. \pb

\subsubsection*{Scaffolder file attribute processing} %{{{3

The sequence entry in the scaffold file allows multiple sequence-editting
attributes which when applied in different combinations will result in
different output sequence. An example is reverse complementing the sequence
then follwing adding sequence inserts. Performing these actions in the reverse
order will produce a difference output sequence. This section therefore
outlines the scaffolder protocol for processing sequence entries. \pb

\paragraph{Reverse sort inserts:} If the sequence entry contains a list of
inserts these are reverse sorted by close position. The insert with the
largest close position is first in the list and inserts with the smallest
close position is last. This preserves the original indented coordinates for
insert during the process of adding inserts to the sequence. \pb

\paragraph{Update sequence with insert:} Each insert sequence is processed
according to any specified attributes. The insert is added to the enclosing
sequence in the region specified by the open and close coordinates. \pb

If the insert added to the sequence is a different length than the region
replaced the sequence start and stop co-ordinates are updated. For example if
a 7bp insert replaced a 5bp region the stop coordinate of the enclosing
sequence would be incremented by the 2bp difference. \pb

\paragraph{Triming sequence:} If the sequence is has start or stop sequences
specified these are used to trip the sequence to these co-ordinates
inclusively. \pb 

\paragraph{Reverse complement sequence:} If the ``reverse'' keyword is
specified the sequence is reverse complemented. This is final step in
processing the sequence with results in the sequence being returned. \pb

\subsection*{Scaffolder usage} %{{{2

Scaffolder provides a standardised set of Ruby classes and methods (the
application programming interface or API) allowing the scaffold to be
manipulated programmatically. This allows scaffolder to be integrated into
existing genomics workflows or used with Ruby build tools such as using Rake.
\pb

Scaffolder also provides a command line interface (CLI) through a scaffolder
binary. This the scaffold sequence to be produced and validated without
requiring any Ruby knowledge. The scaffolder CLI behaves as a standard Unix
tool - returning appropriate exit statuses and providing appropriate manual
pages. The use of both these scaffolder interfaces is outlined in the following
sections. \pb

\subsubsection*{Installation} %{{{3

Scaffolder relies on both the ruby programming language and the RubyGems
package management system to work. These are either already present easily
installed on recent distributions of Mac OSX or Linux. The presences of these
tools can be tested by typing the following on the command line. \pb

\begin{verbatim}
  ruby -v
  gem -v
\end{verbatim}

If both these commands return without error this indicates the necessary
system requirements to install and run scaffolder. The scaffolder API and CLI
can then be installed through RubyGems with the following command.

\begin{verbatim}
  gem install scaffolder scaffolder-tools
\end{verbatim}

To ensure that the scaffolder CLI is accessible the RubyGems `bin' directory
should be in the command line path. Assuming that RubyGems are installed in
~/.gem this can be done by adding the following to the ~/.bashrc file. This
should be adjusted for other shells such as zsh etc..

\begin{verbatim}
  export PATH=~/.gem/bin:$PATH
\end{verbatim}

\subsubsection*{Command Line Interface} %{{{3

The Scaffolder CLI provides functions to validate the scaffold file and build the draft scaffold sequence. Assuming scaffolder has been installed and the
binary is available in the command line path the following command should run without error and list the available functions. \pb

\begin{verbatim}
  scaffolder
\end{verbatim}

Help on a specific command can be found by typing `help' followed by the name
of the command. This will return the corresponding Unix manual page. The
following example will return the manual page for the sequence command. \pb

\begin{verbatim}
  scaffolder help sequence
\end{verbatim} 

The ``sequence'' command builds the fasta sequence from the scaffold and fasta
file. Running this command requires the locations of both the scaffold file and
the fasta file of sequences. This will then return the complete scaffold
sequence. \pb

\begin{verbatim}
  scaffolder sequence scaffold.yml sequences.fna
\end{verbatim}

Scaffolder provides a function to test the scaffold for overlapping insert
coordinates. Overlapping inserts will result in unexpected behaviour as the
coordinates for the first insert may change the insert location for subsequent
inserts. The ``validate'' command will check the scaffold for any such inserts
and return them as a YAML list. \pb

\begin{verbatim}
  scaffolder validate scaffold.yml sequences.fna
\end{verbatim}

\subsubsection*{Application programming interface} %{{{3

Scaffolder provides an API allowing Ruby programs to manipulate the scaffold.
This API is detailed in full on the scaffolder website. The following code
snippet outlines how the API may be used to create a script to replicate the
function of the `scaffolder sequence' command described above. \pb

\begin{verbatim}
  #!/usr/bin/env ruby

  require 'rubygems'
  require 'scaffolder'

  scaffold_file = ARGV.shift
  sequence_file = ARGV.shift

  scaffold = Scaffolder.new(
    YAML.load(File.read(scaffold_file)),
    sequence_file)

  sequence = scaffold.map{|entry| entry.sequence }.join

  puts sequence
\end{verbatim}

This code snippet illustrates that the scaffold object is initialised with two
arguments: the YAML loaded scaffold and the location of the fasta sequence
file. The scaffold is an enumerable object as the next line illustrates the
trivial code required to generate the scaffold sequence. Further details of
the classes and method related to each scaffold entry can be found in the
documentation for the Scaffolder::Region class. \pb

\subsection*{Discussion of Scaffolder Approach} %{{{2

The main aims of scaffolder are two foldfold. The first is produce easy to
install and simplifies the task of genome finishing. The second aim is to
allow to create a tool to facilitate reproducibility in the task of joining
large nucleotide sequences together. \pb

\subsubsection{Simple to use}

Scaffolder is designed to be simple to use as possible. Assuming the existence
of Ruby and RubyGems, scaffolder can be installed in a single command line
step. Scaffolder uses a minimal and compact syntax to described the genome
scaffold. This syntax is simple to construct and edit whilst being succinct
and readable. This aims to allow creating a genome scaffold to relatively
simple to do in a common text editor. Furthermore scaffolder provides
extensive documentation both for the command line tools and for the Scaffolder
Ruby API. Therefore should any part of the scaffolder tool be unclear the
documentation should make an solution easy to find. \pb

\subsubsection{Reproducible genome construction}

Constructing a genome sequence using a plain text scaffold file means the same
sequence is always output for the same file. Joining large nucleotide
sequences manually cannot however be reliably reproduced. The layout of the
scaffold file furthermore provides a human readable record of how the sequence
was constructed. \pb

Configuring the final sequence in the scaffold file means the build is easier
to edit once already constructed compared with working on the sequence alone.
The YAML text format is also much easier to compare differences using standard
text comparison tools such as diff. This makes scaffold files easier to store
in version control systems. This affords genome scaffolding the same benefits
enjoyed by software developers. \pb

\section*{Conclusions} %{{{1

Scaffolder follows the Unix philosophy ``Do one thing and do it well''.
Scaffolder focuses on creating a simple to use and install tool for generating
a genome scaffold. The YAML data format for creating a scaffold file is
standardised and easily manipulated programmatically. This thereby follows
a second Unix tenet: ``If your data structures are good enough, the algorithm
to manipulate them should be trivial.''

\section*{Availability and Requirements} %{{{1

  \begin{description}
    \item[Project name:] Scaffolder
    \item[Project home page:] \scaffolder
    \item[Operating system:] Platform Independent. Tested on Mac OS X and
    Debian.
    \item[Programming language:] Ruby
    \item[Other requirements:] RubyGems
    \item[License:] MIT
    \item[Any restrictions to use by non-academics:] None
  \end{description}

% }}}
\section*{Authors contributions} %{{{1
  The authors declare no competing interests.

\section*{List of Abbreviations Used} %{{{1

  \begin{description}
    \item[YAML:] YAML Ain't Markup Language\cite{yaml}
  \end{description}

\section*{Authors contributions} %{{{1

MDB developed and maintains the scaffolder tool. MDB and HAB wrote the
manuscript.

\section*{Acknowledgements} %{{{1
  \ifthenelse{\boolean{publ}}{\small}{}
  Text for this section \ldots

% Bibliography {{{1
{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{article} }     % Bibliography file (usually '*.bib' ) 

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

\section*{Figures} %{{{1

  \subsection*{Figure 1 - Sample figure title}

  A short description of the figure content should go here.

\section*{Tables} %{{{1

  \subsection*{Table 1 - Sample table title}
    Here is an example of a \emph{small} table in \LaTeX\ using  
    \verb|\tabular{...}|. This is where the description of the table 
    should go. \par \mbox{}
    \par
    \mbox{
      \begin{tabular}{|c|c|c|}
        \hline \multicolumn{3}{|c|}{My Table}\\ \hline
        A1 & B2  & C3 \\ \hline
        A2 & ... & .. \\ \hline
        A3 & ..  & .  \\ \hline
      \end{tabular}
      }
  \subsection*{Table 2 - Sample table title}
    Large tables are attached as separate files but should
    still be described here.

\section*{Additional Files} %{{{1

  \subsection*{Additional file 1 --- Sample additional file title}
    Additional file descriptions text (including details of how to
    view the file, if it is in a non-standard format or the file extension).  This might
    refer to a multi-page table or a figure.

  \subsection*{Additional file 2 --- Sample additional file title}
    Additional file descriptions text.


\end{bmcformat}

\end{document}
